[
  {
    "objectID": "posts/2022-07-22-tilt-noise.html",
    "href": "posts/2022-07-22-tilt-noise.html",
    "title": "Tilt experiments",
    "section": "",
    "text": "Small experiments for how gradients of spatial frequency filters may be perceived as 3D tilts.\nFirst include ImageJ and the mpicbg library that includes a useful integral image implementation and transformation models:\n\n%maven net.imagej:ij:1.53s\n%maven mpicbg:mpicbg_:1.4.0\n\nimport ij.*;\nimport ij.process.*;\nimport java.util.*;\nimport mpicbg.ij.integral.*;\n\nWe want to fill images with white noise, so here are two functions to do so:\n\nvoid fillWhiteNoise(final FloatProcessor ip) {\n\n    final var rnd = new Random(0);\n    final float[] pixels = (float[])ip.getPixels();\n    for (int i = 0; i &lt; pixels.length; ++i)\n        pixels[i] = rnd.nextFloat() * 2 - 1;\n}\n\nvoid fillGaussianNoise(final FloatProcessor ip) {\n\n    final var rnd = new Random(0);\n    final float[] pixels = (float[])ip.getPixels();\n    for (int i = 0; i &lt; pixels.length; ++i)\n        pixels[i] = (float)rnd.nextGaussian();\n}\n\nThis is the Tilt class from mpicbg but with protected members so we can extend it. It implements a the miniature fake method for photography where the image is blurred with an increasingly smooth kernel whose size depends on the distance from a ‘focal line’ in the image. This blur gradient is parameterized with a line segment that is perpedicular to the ‘focal line’ and whose length defines the speed at which the blur filter size increases:\n\npublic class Tilt {\n\n    final protected IntegralImage integral;\n    final protected ImageProcessor ip;\n\n    public Tilt(final ColorProcessor ip) {\n    \n        this.ip = ip;\n        integral = new LongRGBIntegralImage(ip);\n    }\n\n    public Tilt(final ByteProcessor ip) {\n\n        this.ip = ip;\n        integral = new LongIntegralImage(ip);\n    }\n\n    public Tilt(final ShortProcessor ip) {\n    \n        this.ip = ip;\n        integral = new LongIntegralImage( ip );\n    }\n\n    public Tilt(final FloatProcessor ip) {\n    \n        this.ip = ip;\n        integral = new DoubleIntegralImage(ip);\n    }\n    \n    public void setPixel(\n            final int x,\n            final int y,\n            final int xMin,\n            final int yMin,\n            final int xMax,\n            final int yMax,\n            final float scale) {\n        \n        ip.set(x, y, integral.getScaledSum(xMin, yMin, xMax, yMax, scale));\n    }\n\n    public void render(final int x1, final int y1, final int x2, final int y2) {\n    \n        final int w = ip.getWidth() - 1;\n        final int h = ip.getHeight() - 1;\n        final double s = (ip.getWidth() + ip.getHeight()) * 2.0;\n\n        final int dx = x2 - x1;\n        final int dy = y2 - y1;\n\n        for (int y = 0; y &lt;= h; ++y) {\n            final double yt = y - y1;\n            for (int x = 0; x &lt;= w; ++x) {\n                final double xt = x - x1;\n\n                final double r = (dx * xt + dy * yt) / s;\n                final int ri = r &lt; 0 ? (int)-r : (int)r;\n\n                final int yMin = Math.max(-1, y - ri - 1);\n                final int yMax = Math.min(h, y + ri);\n                final int xMin = Math.max(-1, x - ri - 1);\n                final int xMax = Math.min(w, x + ri);\n                final float scale = 1.0f / (xMax - xMin) / (yMax - yMin);\n                setPixel(x, y, xMin, yMin, xMax, yMax, scale);\n            }\n        }\n    }\n}\n\nNow a variant of the Tilt class that does not normalize the sum of the blur filter by the number of pixels but by the square root of the number of pixels:\n\npublic class Tilt2 extends Tilt {\n\n    public Tilt2(final ColorProcessor ip) { super(ip); }\n    public Tilt2(final ByteProcessor ip) { super(ip); }\n    public Tilt2(final ShortProcessor ip) { super(ip); }\n    public Tilt2(final FloatProcessor ip) { super(ip); }\n\n    public void setPixel(\n            final int x,\n            final int y,\n            final int xMin,\n            final int yMin,\n            final int xMax,\n            final int yMax,\n            final float scale) {\n        \n        ip.set(x, y, integral.getScaledSum(xMin, yMin, xMax, yMax, (float)Math.sqrt(scale)));\n//         ip.set(x, y, integral.getScaledSum(xMin, yMin, xMax, yMax, 1.0f));\n    }\n}\n\nLet’s make an image and fill it with noise. We create an image that is 10 times larger than what we want to display so we can use area averaging to present a downscaled version with minimal aliasing:\n\nfinal int scale = 10;\nvar ip = new FloatProcessor(512 * scale, 512 * scale);\nfillWhiteNoise(ip);\nip.setMinAndMax(-2, 2);\nScale.create(ip).scale(1.0 / scale).getBufferedImage();\n\n\n\n\n\n\n\n\nNow lets filter this with box filters of increasing size along a vertical gradient:\n\nvar ip2 = ip.duplicate();\nvar tilt2 = new Tilt2((FloatProcessor)ip2);\ntilt2.render(0, 0, 0, 127);\nScale.create(ip2).scale(1.0 / scale).getBufferedImage();\n\n\n\n\n\n\n\n\nAnd now the same with a horizontal gradient:\n\nvar ip2 = ip.duplicate();\nvar tilt2 = new Tilt2((FloatProcessor)ip2);\ntilt2.render(0, 0, 127, 0);\nScale.create(ip2).scale(1.0 / scale).getBufferedImage();\n\n\n\n\n\n\n\n\nOr a bit tilted:\n\nvar ip2 = ip.duplicate();\nvar tilt2 = new Tilt2((FloatProcessor)ip2);\ntilt2.render(0, 0, 63, 127);\nScale.create(ip2).scale(1.0 / scale).getBufferedImage();\n\n\n\n\n\n\n\n\n\nvar ip = new FloatProcessor(512, 512);\nfillWhiteNoise(ip);\nip2 = ip.duplicate();\nvar mean = Mean.create(ip2);\nmean.mean(2);\nnew ImageJ();\nnew ImagePlus(\"noise\", ip).show();\nnew ImagePlus(\"mean\", ip2).show();\n\n\nImagePlus imp = IJ.openImage(\"https://pixy.org/src2/680/6804381.jpg\");\nvar ip = imp.getProcessor().convertToFloatProcessor();\nip.add(-127);\nip.multiply(1.0 / 127);\nip.setMinAndMax(-2, 2);\n//ip.getBufferedImage();\nvar ipScaled = Scale.create(ip).scale(0.4);\nScale.create(ipScaled).scale(0.5).getBufferedImage();\n\nError loading image\nhttps://pixy.org/src2/680/6804381.jpg\n\n\nEvalException: Cannot invoke \"ij.ImagePlus.getProcessor()\" because \"REPL.$JShell$45.imp\" is null\n\n\n\nvar ip2 = ipScaled.duplicate();\nvar tilt2 = new Tilt2((FloatProcessor)ip2);\ntilt2.render(0, ipScaled.getHeight(), 0, ipScaled.getHeight() - 255);\nScale.create(ip2).scale(0.5).getBufferedImage();\n\nCompilationException: \n\n\n\nnew ImageJ();\nvar ip = new FloatProcessor(1014, 1024);\nfillGaussianNoise(ip);\nnew ImagePlus(\"image\", ip).show();\nnew InteractiveTilt().run(\"\");"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Saalfeld lab blog",
    "section": "",
    "text": "Integral image mapping\n\n\n\n\n\n\nintegral image\n\n\nimagej\n\n\nantialiazing\n\n\ntransformation\n\n\nmpicbg\n\n\n\nRender transformed images with fewer aliasing artifacts.\n\n\n\n\n\nJul 22, 2022\n\n\nStephan Saalfeld\n\n\n\n\n\n\n\n\n\n\n\n\nTilt experiments\n\n\n\n\n\n\nintegral image\n\n\nimagej\n\n\ntilt\n\n\nfrequency filter\n\n\nmpicbg\n\n\n\nGradients of spatial frequency filters may be perceived as 3D tilts.\n\n\n\n\n\nJul 22, 2022\n\n\nStephan Saalfeld\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This blog is for news and chatter\nThe Saalfeld lab develops scalable image analysis methods as open source software. We use this blog to post unfinished scripts and ideas and to communicate stuff that didn’t work out."
  },
  {
    "objectID": "posts/2022-07-22-integral-image-mapping.html",
    "href": "posts/2022-07-22-integral-image-mapping.html",
    "title": "Integral image mapping",
    "section": "",
    "text": "Small experiments for rendering transformed images without aliasing artifacts. We use integral images to approximate an appropriately scaled kernel for each target pixel with a box filter of the size of one scaled pixel.\nFirst include ImageJ and the mpicbg library that includes a useful integral image implementationa and transformation models:\n\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven net.imagej:ij:1.53s\n%maven mpicbg:mpicbg_:1.4.0\n%maven sc.fiji:panorama_:3.0.2\n\nimport ij.*;\nimport ij.process.*;\nimport java.util.*;\nimport mpicbg.ij.*;\nimport mpicbg.ij.integral.*;\nimport mpicbg.models.*;\nimport mpicbg.panorama.*;\n\nThis is the TransformMapping class from mpicbg but with a member source, so we can make and re-use an integral image for all subsequent mappings:\n\npublic class PrettyMapping&lt;T extends CoordinateTransform&gt; {\n\n    final protected IntegralImage integral;\n    final protected ImageProcessor source;\n    final protected T transform;\n    final public T getTransform(){ return transform; }\n    \n    private static final IntegralImage integrate(final ImageProcessor ip) {\n        \n        if (FloatProcessor.class.isInstance(ip))\n            return new DoubleIntegralImage((FloatProcessor)ip);\n        else if (ByteProcessor.class.isInstance(ip))\n            return new LongIntegralImage((ByteProcessor)ip);\n        else if (ShortProcessor.class.isInstance(ip))\n            return new LongIntegralImage((ShortProcessor)ip);\n        else if (ColorProcessor.class.isInstance(ip))\n            return new LongRGBIntegralImage((ColorProcessor)ip);\n        else\n            return null;\n    }\n\n    private static final double squareLength(\n            final double x0,\n            final double y0,\n            final double x1,\n            final double y1) {\n        \n        final double dx = x1 - x0;\n        final double dy = y1 - y0;\n        \n        return dx * dx + dy * dy;\n    }\n    \n    private static final double length(\n            final double x0,\n            final double y0,\n            final double x1,\n            final double y1) {\n        \n        return Math.sqrt(squareLength(x0, y0, x1, y1));\n    }\n\n    public PrettyMapping(\n            final ImageProcessor source,\n            final T transform) {\n        \n        this.source = source;\n        this.transform = transform;\n        this.integral = integrate(source);\n    }\n    \n    public void map(final ImageProcessor target) {\n        \n        source.setInterpolationMethod(ImageProcessor.BICUBIC);\n    \n        final double[] t = new double[3];\n        final int sw = source.getWidth() - 1;\n        final int sh = source.getHeight() - 1;\n        final int tw = target.getWidth();\n        final int th = target.getHeight();\n        \n        for (int y = 0; y &lt;= th; ++y) {\n            final double y0 = y - 0.5;\n            final double y1 = y + 0.5;\n            for (int x = 0; x &lt;= tw; ++x) {\n                t[0] = x;\n                t[1] = y;\n                t[2] = 1.0;\n                transform.applyInPlace(t);\n                \n                final double t0 = t[0];\n                final double t1 = t[1];\n                \n                if (t0 &gt;= 0 && t0 &lt;= sw && t1 &gt;= 0 && t1 &lt;= sh) {\n                    final double x0 = x - 0.5;\n                    final double x1 = x + 0.5;\n\n                    t[0] = x0;\n                    t[1] = y0;\n                    t[2] = 1.0;\n                    transform.applyInPlace(t);\n                    final double x00 = t[0];\n                    final double y00 = t[1];\n                    \n                    t[0] = x1;\n                    t[1] = y0;\n                    t[2] = 1.0;\n                    transform.applyInPlace(t);\n                    final double x10 = t[0];\n                    final double y10 = t[1];\n\n                    t[0] = x0;\n                    t[1] = y1;\n                    t[2] = 1.0;\n                    transform.applyInPlace(t);\n                    final double x01 = t[0];\n                    final double y01 = t[1];\n\n                    t[0] = x1;\n                    t[1] = y1;\n                    t[2] = 1.0;\n                    transform.applyInPlace(t);\n                    final double x11 = t[0];\n                    final double y11 = t[1];\n\n                    final double avgHalfLength = (\n                        length(x00, y00, x10, y10) +\n                        length(x10, y10, x11, y11) +\n                        length(x11, y11, x01, y01) +\n                        length(x01, y01, x00, y00)) / 8.0;\n                    \n                    if (avgHalfLength &gt; 1) {\n                        final int tx = (int)(t0 + 0.5);\n                        final int ty = (int)(t1 + 0.5);\n                        final int r = (int)(avgHalfLength + 0.5);\n                    \n                        final int xMin = Math.max(-1, tx - r - 1);\n                        final int xMax = Math.min(sw, tx + r);\n                        final int yMin = Math.max(-1, ty - r - 1);\n                        final int yMax = Math.min(sh, ty + r);\n                        final float scale = 1.0f / (xMax - xMin) / (yMax - yMin);\n                        target.set(x, y, integral.getScaledSum(xMin, yMin, xMax, yMax, scale));\n                    } else\n                        target.putPixel(x, y, source.getPixelInterpolated(t0, t1));\n                }\n            }\n        }\n    }\n}\n\nLet’s load an image from somewhere. This one is large, so we scale it down a bit and display it even smaller:\n\nImagePlus imp = IJ.openImage(\"https://pixy.org/src2/680/6804381.jpg\");\nvar ip = imp.getProcessor();\nip.setMinAndMax(64, 255 - 64);\n//ip.getBufferedImage();\nvar ipScaled = Scale.create(ip).scale(0.4);\nScale.create(ipScaled).scale(0.5).getBufferedImage();\n\n\n\n\n\n\n\n\nNow we transform this with a perspective transformation:\n\ndouble w = ipScaled.getWidth();\ndouble h = ipScaled.getHeight();\ndouble d = 500;\n\nvar homography = new HomographyModel2D();\nhomography.fit(\n    new double[][]{\n        {d, w - d, -d, w + d},\n        {0, 0, h - 2 * d, h - 2 * d}},\n    new double[][]{\n        {0, w, 0, w},\n        {0, 0, h, h}},\n    new double[]{1, 1, 1, 1});\nvar mapping = new PrettyMapping(ipScaled, homography);\nvar ip2 = ip.createProcessor((int)w, (int)h - 2 * (int)d);\nmapping.map(ip2);\nScale.create(ip2).scale(0.5).getBufferedImage();\n\n\n\n\n\n\n\n\nNow let’s see how it looks with interpolation only, i.e. if the kernel does not integrate over transformed pixels that are larger than one source pixel:\n\nvar mapping2 = new TransformMapping(homography);\nvar ip3 = ip.createProcessor((int)w, (int)h - 2 * (int)d);\nmapping2.mapInverseInterpolated(ipScaled, ip3);\nScale.create(ip3).scale(0.5).getBufferedImage();\n\n\n\n\n\n\n\n\nNow let’s do an experiment with a proper camera model. We can use the RectlinearCamera from Fiji’s panorama viewer, but to use this with PrettyMapping we have to run it through a facade that applies the inverse of the transformation instead of the forward:\n\npublic class InverseOf implements CoordinateTransform {\n    \n    protected InverseCoordinateTransform t;\n    \n    public InverseOf(final InverseCoordinateTransform t) {\n        \n        this.t = t;\n    }\n    \n    public void applyInPlace(final double[] point) {\n        \n        try { t.applyInverseInPlace(point); }\n        catch (final NoninvertibleModelException e ) {\n            display(e);\n        }\n    }\n    \n    public double[] apply(final double[] point) {\n        \n        final double[] copy = point.clone();\n        applyInPlace(copy);\n        return copy;\n    }\n}\n\n\ndouble w = ipScaled.getWidth();\ndouble h = ipScaled.getHeight();\ndouble d = 1000;\n\nvar camera = new RectlinearCamera();\ncamera.setSourceWidth(w - 1);\ncamera.setSourceHeight(h - 1);\ncamera.setTargetWidth(w);\ncamera.setTargetHeight(h);\ncamera.setF(0.125);\ncamera.pan(Math.PI * 0.05);\n\nvar mapping = new PrettyMapping(ipScaled, new InverseOf(camera));\nvar ip2 = ip.createProcessor((int)camera.getTargetWidth(), (int)camera.getTargetHeight());\nmapping.map(ip2);\n\ncamera.pan(-Math.PI / 2);\nmapping.map(ip2);\n\nScale.create(ip2).scale(0.5).getBufferedImage();"
  }
]